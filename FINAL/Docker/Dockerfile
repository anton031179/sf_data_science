FROM python:3.10
# укажем путь к рабочей папке нашего приложения внутри docker-контейнера (вместо /usr/src/app вы можете прописать любой путь, 
# по которому хотите поместить файлы внутри контейнера) 
WORKDIR /src/app  
# скопируем в рабочую директорию файлы из корня нашего приложения. Для этого используется ключевое слово COPY. 
# В качестве первого аргумента этой директивы указываются папки или файлы, которые мы хотим скопировать с локальной машины, 
# в качестве второго аргумента — куда мы хотим поместить эти копии в контейнере.
COPY ./src/ .  

# создадим файл requirements.txt рядом с Dockerfile. Укажем в нём необходимые библиотеки и их версии:
# (project_a_venv) $ pip freeze -r requirements.txt
# !pip freeze > requirements.txt
# Теперь необходимо переместить файл с зависимостями в наш контейнер, 
# а после запустить команду для установки зависимостей.
# Для этого напишем перед командой CMD, запускающей выполнение скрипта в Dockerfile, строки:
COPY ./requirements.txt ./ 
RUN pip install -r requirements.txt


# запишем команду для запуска скрипта, который будет выполняться вместе с запуском контейнера. 
# Для этого используется директива CMD
CMD ["python", "./server.py"]


# Теперь откроем терминал, перейдём в папку с нашим приложением и запустим команду для сборки контейнера (docker build):
# $ docker build -t rea_image .

# Чтобы убедиться, что образ собран, а также посмотреть список доступных образов, можно использовать команду:
# $ docker images

# Так как образы занимают место в памяти компьютера, неактуальные образы можно удалять с помощью команды docker rmi:
# $ docker rmi <image_id>

### Запустим контейнер на основе нашего образа — для этого используется команда docker run <имя образа>:
## $ docker run -it --rm --name=rea_container rea_image

# так как в нашем контейнере будет работать веб-приложение, нам необходимо открыть внешним приложениям доступ к порту, 
# на котором запущено приложение. Это делается с помощью указания ключа --publish или его сокращённой версии -p. 
# В аргументе этой команды указывается диапазон из номеров портов контейнера, которые мы хотим сделать публичными. 
# В нашем приложении мы указали, что нам нужен порт 5000, а значит, диапазон будет выглядеть как 5000:5000
# $ docker run -it --rm --name=server_container -p=5000:5000 rea_image


# Чтобы посмотреть список запущенных контейнеров, можно воспользоваться командой docker ps. 
#По умолчанию она выводит список активных контейнеров. Для вывода списка всех контейнеров используйте ключ -a, 
# но предварительно перезапустите контейнер без ключа --rm, так как данный ключ удаляет контейнеры.
# Запустите команду в соседнем терминале одновременно с контейнером.
# $ docker ps -a

# Docker не сохраняет файлы внутри контейнера, так как внутри контейнера своя отдельная файловая система.
# Что же делать? Ответ очень прост — нам нужно связать контейнер с локальной файловой системой на нашем компьютере.
# Для этого укажем параметр --volume или ключ -v в команде docker run.
# Ключ -v требует указания путей, которые записываются в формате <путь на локальной машине>:<путь в контейнере>:
# $ docker run -it --rm -v $PWD/src/output/:/usr/src/app/output  --name=rea_container rea_image

# Выполним POST-запрос, запустив код клиентского приложения в соседнем терминале
# $ python3 tests/client.py

